/* Generated by Purgatory 2014 */

package ch.epfl.data
package legobase
package deep

import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._

trait GroupByClassOps extends Base with OptimalStringOps {
  // Type representation
  case object GroupByClassType extends TypeRep[GroupByClass] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = GroupByClassType
    val name = "GroupByClass"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[GroupByClass]
  }
  implicit val typeGroupByClass = GroupByClassType
  implicit class GroupByClassRep(self: Rep[GroupByClass]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = groupByClassGetField(self, key)
    def L_LINESTATUS: Rep[Char] = groupByClass_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Char] = groupByClass_Field_L_RETURNFLAG(self)
  }
  object GroupByClass {

  }
  // constructors
  def __newGroupByClass(L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char]): Rep[GroupByClass] = groupByClassNew(L_RETURNFLAG, L_LINESTATUS)
  // case classes
  case class GroupByClassNew(L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char]) extends ConstructorDef[GroupByClass](List(), "GroupByClass", List(List(L_RETURNFLAG, L_LINESTATUS))) {
    override def curriedConstructor = (copy _).curried
  }

  case class GroupByClassGetField(self: Rep[GroupByClass], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class GroupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]) extends FieldDef[Char](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class GroupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]) extends FieldDef[Char](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def groupByClassNew(L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char]): Rep[GroupByClass] = GroupByClassNew(L_RETURNFLAG, L_LINESTATUS)
  def groupByClassGetField(self: Rep[GroupByClass], key: Rep[String]): Rep[Option[Any]] = GroupByClassGetField(self, key)
  def groupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]): Rep[Char] = GroupByClass_Field_L_LINESTATUS(self)
  def groupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]): Rep[Char] = GroupByClass_Field_L_RETURNFLAG(self)
  type GroupByClass = ch.epfl.data.legobase.queryengine.GroupByClass
}
trait GroupByClassImplicits {
  // Add implicit conversions here!
}
trait GroupByClassImplementations {

}
trait GroupByClassPartialEvaluation extends GroupByClassComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def groupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]): Rep[Char] = self match {
    case Def(node: GroupByClassNew) => node.L_LINESTATUS
    case _                          => super.groupByClass_Field_L_LINESTATUS(self)
  }
  override def groupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]): Rep[Char] = self match {
    case Def(node: GroupByClassNew) => node.L_RETURNFLAG
    case _                          => super.groupByClass_Field_L_RETURNFLAG(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait GroupByClassComponent extends GroupByClassOps with GroupByClassImplicits {}

trait Q3GRPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object Q3GRPRecordType extends TypeRep[Q3GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q3GRPRecordType
    val name = "Q3GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q3GRPRecord]
  }
  implicit val typeQ3GRPRecord = Q3GRPRecordType
  implicit class Q3GRPRecordRep(self: Rep[Q3GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q3GRPRecordGetField(self, key)
    def O_SHIPPRIORITY: Rep[Int] = q3GRPRecord_Field_O_SHIPPRIORITY(self)
    def O_ORDERDATE: Rep[Int] = q3GRPRecord_Field_O_ORDERDATE(self)
    def L_ORDERKEY: Rep[Int] = q3GRPRecord_Field_L_ORDERKEY(self)
  }
  object Q3GRPRecord {

  }
  // constructors
  def __newQ3GRPRecord(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Int], O_SHIPPRIORITY: Rep[Int]): Rep[Q3GRPRecord] = q3GRPRecordNew(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY)
  // case classes
  case class Q3GRPRecordNew(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Int], O_SHIPPRIORITY: Rep[Int]) extends ConstructorDef[Q3GRPRecord](List(), "Q3GRPRecord", List(List(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q3GRPRecordGetField(self: Rep[Q3GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q3GRPRecordNew(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Int], O_SHIPPRIORITY: Rep[Int]): Rep[Q3GRPRecord] = Q3GRPRecordNew(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY)
  def q3GRPRecordGetField(self: Rep[Q3GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q3GRPRecordGetField(self, key)
  def q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_O_SHIPPRIORITY(self)
  def q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_O_ORDERDATE(self)
  def q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_L_ORDERKEY(self)
  type Q3GRPRecord = ch.epfl.data.legobase.queryengine.Q3GRPRecord
}
trait Q3GRPRecordImplicits {
  // Add implicit conversions here!
}
trait Q3GRPRecordImplementations {

}
trait Q3GRPRecordPartialEvaluation extends Q3GRPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]): Rep[Int] = self match {
    case Def(node: Q3GRPRecordNew) => node.O_SHIPPRIORITY
    case _                         => super.q3GRPRecord_Field_O_SHIPPRIORITY(self)
  }
  override def q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]): Rep[Int] = self match {
    case Def(node: Q3GRPRecordNew) => node.O_ORDERDATE
    case _                         => super.q3GRPRecord_Field_O_ORDERDATE(self)
  }
  override def q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]): Rep[Int] = self match {
    case Def(node: Q3GRPRecordNew) => node.L_ORDERKEY
    case _                         => super.q3GRPRecord_Field_L_ORDERKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q3GRPRecordComponent extends Q3GRPRecordOps with Q3GRPRecordImplicits {}

trait Q7GRPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object Q7GRPRecordType extends TypeRep[Q7GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q7GRPRecordType
    val name = "Q7GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q7GRPRecord]
  }
  implicit val typeQ7GRPRecord = Q7GRPRecordType
  implicit class Q7GRPRecordRep(self: Rep[Q7GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q7GRPRecordGetField(self, key)
    def L_YEAR: Rep[Int] = q7GRPRecord_Field_L_YEAR(self)
    def CUST_NATION: Rep[OptimalString] = q7GRPRecord_Field_CUST_NATION(self)
    def SUPP_NATION: Rep[OptimalString] = q7GRPRecord_Field_SUPP_NATION(self)
  }
  object Q7GRPRecord {

  }
  // constructors
  def __newQ7GRPRecord(SUPP_NATION: Rep[OptimalString], CUST_NATION: Rep[OptimalString], L_YEAR: Rep[Int]): Rep[Q7GRPRecord] = q7GRPRecordNew(SUPP_NATION, CUST_NATION, L_YEAR)
  // case classes
  case class Q7GRPRecordNew(SUPP_NATION: Rep[OptimalString], CUST_NATION: Rep[OptimalString], L_YEAR: Rep[Int]) extends ConstructorDef[Q7GRPRecord](List(), "Q7GRPRecord", List(List(SUPP_NATION, CUST_NATION, L_YEAR))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q7GRPRecordGetField(self: Rep[Q7GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q7GRPRecord_Field_L_YEAR(self: Rep[Q7GRPRecord]) extends FieldDef[Int](self, "L_YEAR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q7GRPRecord_Field_CUST_NATION(self: Rep[Q7GRPRecord]) extends FieldDef[OptimalString](self, "CUST_NATION") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q7GRPRecord_Field_SUPP_NATION(self: Rep[Q7GRPRecord]) extends FieldDef[OptimalString](self, "SUPP_NATION") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q7GRPRecordNew(SUPP_NATION: Rep[OptimalString], CUST_NATION: Rep[OptimalString], L_YEAR: Rep[Int]): Rep[Q7GRPRecord] = Q7GRPRecordNew(SUPP_NATION, CUST_NATION, L_YEAR)
  def q7GRPRecordGetField(self: Rep[Q7GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q7GRPRecordGetField(self, key)
  def q7GRPRecord_Field_L_YEAR(self: Rep[Q7GRPRecord]): Rep[Int] = Q7GRPRecord_Field_L_YEAR(self)
  def q7GRPRecord_Field_CUST_NATION(self: Rep[Q7GRPRecord]): Rep[OptimalString] = Q7GRPRecord_Field_CUST_NATION(self)
  def q7GRPRecord_Field_SUPP_NATION(self: Rep[Q7GRPRecord]): Rep[OptimalString] = Q7GRPRecord_Field_SUPP_NATION(self)
  type Q7GRPRecord = ch.epfl.data.legobase.queryengine.Q7GRPRecord
}
trait Q7GRPRecordImplicits {
  // Add implicit conversions here!
}
trait Q7GRPRecordImplementations {

}
trait Q7GRPRecordPartialEvaluation extends Q7GRPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def q7GRPRecord_Field_L_YEAR(self: Rep[Q7GRPRecord]): Rep[Int] = self match {
    case Def(node: Q7GRPRecordNew) => node.L_YEAR
    case _                         => super.q7GRPRecord_Field_L_YEAR(self)
  }
  override def q7GRPRecord_Field_CUST_NATION(self: Rep[Q7GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q7GRPRecordNew) => node.CUST_NATION
    case _                         => super.q7GRPRecord_Field_CUST_NATION(self)
  }
  override def q7GRPRecord_Field_SUPP_NATION(self: Rep[Q7GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q7GRPRecordNew) => node.SUPP_NATION
    case _                         => super.q7GRPRecord_Field_SUPP_NATION(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q7GRPRecordComponent extends Q7GRPRecordOps with Q7GRPRecordImplicits {}

trait Q9GRPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object Q9GRPRecordType extends TypeRep[Q9GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q9GRPRecordType
    val name = "Q9GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q9GRPRecord]
  }
  implicit val typeQ9GRPRecord = Q9GRPRecordType
  implicit class Q9GRPRecordRep(self: Rep[Q9GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q9GRPRecordGetField(self, key)
    def O_YEAR: Rep[Int] = q9GRPRecord_Field_O_YEAR(self)
    def NATION: Rep[OptimalString] = q9GRPRecord_Field_NATION(self)
  }
  object Q9GRPRecord {

  }
  // constructors
  def __newQ9GRPRecord(NATION: Rep[OptimalString], O_YEAR: Rep[Int]): Rep[Q9GRPRecord] = q9GRPRecordNew(NATION, O_YEAR)
  // case classes
  case class Q9GRPRecordNew(NATION: Rep[OptimalString], O_YEAR: Rep[Int]) extends ConstructorDef[Q9GRPRecord](List(), "Q9GRPRecord", List(List(NATION, O_YEAR))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q9GRPRecordGetField(self: Rep[Q9GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q9GRPRecord_Field_O_YEAR(self: Rep[Q9GRPRecord]) extends FieldDef[Int](self, "O_YEAR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q9GRPRecord_Field_NATION(self: Rep[Q9GRPRecord]) extends FieldDef[OptimalString](self, "NATION") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q9GRPRecordNew(NATION: Rep[OptimalString], O_YEAR: Rep[Int]): Rep[Q9GRPRecord] = Q9GRPRecordNew(NATION, O_YEAR)
  def q9GRPRecordGetField(self: Rep[Q9GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q9GRPRecordGetField(self, key)
  def q9GRPRecord_Field_O_YEAR(self: Rep[Q9GRPRecord]): Rep[Int] = Q9GRPRecord_Field_O_YEAR(self)
  def q9GRPRecord_Field_NATION(self: Rep[Q9GRPRecord]): Rep[OptimalString] = Q9GRPRecord_Field_NATION(self)
  type Q9GRPRecord = ch.epfl.data.legobase.queryengine.Q9GRPRecord
}
trait Q9GRPRecordImplicits {
  // Add implicit conversions here!
}
trait Q9GRPRecordImplementations {

}
trait Q9GRPRecordPartialEvaluation extends Q9GRPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def q9GRPRecord_Field_O_YEAR(self: Rep[Q9GRPRecord]): Rep[Int] = self match {
    case Def(node: Q9GRPRecordNew) => node.O_YEAR
    case _                         => super.q9GRPRecord_Field_O_YEAR(self)
  }
  override def q9GRPRecord_Field_NATION(self: Rep[Q9GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q9GRPRecordNew) => node.NATION
    case _                         => super.q9GRPRecord_Field_NATION(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q9GRPRecordComponent extends Q9GRPRecordOps with Q9GRPRecordImplicits {}

trait Q10GRPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object Q10GRPRecordType extends TypeRep[Q10GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q10GRPRecordType
    val name = "Q10GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q10GRPRecord]
  }
  implicit val typeQ10GRPRecord = Q10GRPRecordType
  implicit class Q10GRPRecordRep(self: Rep[Q10GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q10GRPRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = q10GRPRecord_Field_C_COMMENT(self)
    def C_ADDRESS: Rep[OptimalString] = q10GRPRecord_Field_C_ADDRESS(self)
    def N_NAME: Rep[OptimalString] = q10GRPRecord_Field_N_NAME(self)
    def C_PHONE: Rep[OptimalString] = q10GRPRecord_Field_C_PHONE(self)
    def C_ACCTBAL: Rep[Double] = q10GRPRecord_Field_C_ACCTBAL(self)
    def C_NAME: Rep[OptimalString] = q10GRPRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = q10GRPRecord_Field_C_CUSTKEY(self)
  }
  object Q10GRPRecord {

  }
  // constructors
  def __newQ10GRPRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_PHONE: Rep[OptimalString], N_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[Q10GRPRecord] = q10GRPRecordNew(C_CUSTKEY, C_NAME, C_ACCTBAL, C_PHONE, N_NAME, C_ADDRESS, C_COMMENT)
  // case classes
  case class Q10GRPRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_PHONE: Rep[OptimalString], N_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends ConstructorDef[Q10GRPRecord](List(), "Q10GRPRecord", List(List(C_CUSTKEY, C_NAME, C_ACCTBAL, C_PHONE, N_NAME, C_ADDRESS, C_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q10GRPRecordGetField(self: Rep[Q10GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q10GRPRecord_Field_C_COMMENT(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_ADDRESS(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_N_NAME(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "N_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_PHONE(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_ACCTBAL(self: Rep[Q10GRPRecord]) extends FieldDef[Double](self, "C_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_NAME(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_CUSTKEY(self: Rep[Q10GRPRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q10GRPRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_PHONE: Rep[OptimalString], N_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[Q10GRPRecord] = Q10GRPRecordNew(C_CUSTKEY, C_NAME, C_ACCTBAL, C_PHONE, N_NAME, C_ADDRESS, C_COMMENT)
  def q10GRPRecordGetField(self: Rep[Q10GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q10GRPRecordGetField(self, key)
  def q10GRPRecord_Field_C_COMMENT(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_COMMENT(self)
  def q10GRPRecord_Field_C_ADDRESS(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_ADDRESS(self)
  def q10GRPRecord_Field_N_NAME(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_N_NAME(self)
  def q10GRPRecord_Field_C_PHONE(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_PHONE(self)
  def q10GRPRecord_Field_C_ACCTBAL(self: Rep[Q10GRPRecord]): Rep[Double] = Q10GRPRecord_Field_C_ACCTBAL(self)
  def q10GRPRecord_Field_C_NAME(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_NAME(self)
  def q10GRPRecord_Field_C_CUSTKEY(self: Rep[Q10GRPRecord]): Rep[Int] = Q10GRPRecord_Field_C_CUSTKEY(self)
  type Q10GRPRecord = ch.epfl.data.legobase.queryengine.Q10GRPRecord
}
trait Q10GRPRecordImplicits {
  // Add implicit conversions here!
}
trait Q10GRPRecordImplementations {

}
trait Q10GRPRecordPartialEvaluation extends Q10GRPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def q10GRPRecord_Field_C_COMMENT(self: Rep[Q10GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q10GRPRecordNew) => node.C_COMMENT
    case _                          => super.q10GRPRecord_Field_C_COMMENT(self)
  }
  override def q10GRPRecord_Field_C_ADDRESS(self: Rep[Q10GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q10GRPRecordNew) => node.C_ADDRESS
    case _                          => super.q10GRPRecord_Field_C_ADDRESS(self)
  }
  override def q10GRPRecord_Field_N_NAME(self: Rep[Q10GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q10GRPRecordNew) => node.N_NAME
    case _                          => super.q10GRPRecord_Field_N_NAME(self)
  }
  override def q10GRPRecord_Field_C_PHONE(self: Rep[Q10GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q10GRPRecordNew) => node.C_PHONE
    case _                          => super.q10GRPRecord_Field_C_PHONE(self)
  }
  override def q10GRPRecord_Field_C_ACCTBAL(self: Rep[Q10GRPRecord]): Rep[Double] = self match {
    case Def(node: Q10GRPRecordNew) => node.C_ACCTBAL
    case _                          => super.q10GRPRecord_Field_C_ACCTBAL(self)
  }
  override def q10GRPRecord_Field_C_NAME(self: Rep[Q10GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q10GRPRecordNew) => node.C_NAME
    case _                          => super.q10GRPRecord_Field_C_NAME(self)
  }
  override def q10GRPRecord_Field_C_CUSTKEY(self: Rep[Q10GRPRecord]): Rep[Int] = self match {
    case Def(node: Q10GRPRecordNew) => node.C_CUSTKEY
    case _                          => super.q10GRPRecord_Field_C_CUSTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q10GRPRecordComponent extends Q10GRPRecordOps with Q10GRPRecordImplicits {}

trait Q16GRPRecord1Ops extends Base with OptimalStringOps {
  // Type representation
  case object Q16GRPRecord1Type extends TypeRep[Q16GRPRecord1] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q16GRPRecord1Type
    val name = "Q16GRPRecord1"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q16GRPRecord1]
  }
  implicit val typeQ16GRPRecord1 = Q16GRPRecord1Type
  implicit class Q16GRPRecord1Rep(self: Rep[Q16GRPRecord1]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q16GRPRecord1GetField(self, key)
    def PS_SUPPKEY: Rep[Int] = q16GRPRecord1_Field_PS_SUPPKEY(self)
    def P_SIZE: Rep[Int] = q16GRPRecord1_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = q16GRPRecord1_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = q16GRPRecord1_Field_P_BRAND(self)
  }
  object Q16GRPRecord1 {

  }
  // constructors
  def __newQ16GRPRecord1(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], PS_SUPPKEY: Rep[Int]): Rep[Q16GRPRecord1] = q16GRPRecord1New(P_BRAND, P_TYPE, P_SIZE, PS_SUPPKEY)
  // case classes
  case class Q16GRPRecord1New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], PS_SUPPKEY: Rep[Int]) extends ConstructorDef[Q16GRPRecord1](List(), "Q16GRPRecord1", List(List(P_BRAND, P_TYPE, P_SIZE, PS_SUPPKEY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord1GetField(self: Rep[Q16GRPRecord1], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord1_Field_PS_SUPPKEY(self: Rep[Q16GRPRecord1]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord1_Field_P_SIZE(self: Rep[Q16GRPRecord1]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord1_Field_P_TYPE(self: Rep[Q16GRPRecord1]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord1_Field_P_BRAND(self: Rep[Q16GRPRecord1]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q16GRPRecord1New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], PS_SUPPKEY: Rep[Int]): Rep[Q16GRPRecord1] = Q16GRPRecord1New(P_BRAND, P_TYPE, P_SIZE, PS_SUPPKEY)
  def q16GRPRecord1GetField(self: Rep[Q16GRPRecord1], key: Rep[String]): Rep[Option[Any]] = Q16GRPRecord1GetField(self, key)
  def q16GRPRecord1_Field_PS_SUPPKEY(self: Rep[Q16GRPRecord1]): Rep[Int] = Q16GRPRecord1_Field_PS_SUPPKEY(self)
  def q16GRPRecord1_Field_P_SIZE(self: Rep[Q16GRPRecord1]): Rep[Int] = Q16GRPRecord1_Field_P_SIZE(self)
  def q16GRPRecord1_Field_P_TYPE(self: Rep[Q16GRPRecord1]): Rep[OptimalString] = Q16GRPRecord1_Field_P_TYPE(self)
  def q16GRPRecord1_Field_P_BRAND(self: Rep[Q16GRPRecord1]): Rep[OptimalString] = Q16GRPRecord1_Field_P_BRAND(self)
  type Q16GRPRecord1 = ch.epfl.data.legobase.queryengine.Q16GRPRecord1
}
trait Q16GRPRecord1Implicits {
  // Add implicit conversions here!
}
trait Q16GRPRecord1Implementations {

}
trait Q16GRPRecord1PartialEvaluation extends Q16GRPRecord1Component with BasePartialEvaluation {
  // Immutable field inlining 
  override def q16GRPRecord1_Field_PS_SUPPKEY(self: Rep[Q16GRPRecord1]): Rep[Int] = self match {
    case Def(node: Q16GRPRecord1New) => node.PS_SUPPKEY
    case _                           => super.q16GRPRecord1_Field_PS_SUPPKEY(self)
  }
  override def q16GRPRecord1_Field_P_SIZE(self: Rep[Q16GRPRecord1]): Rep[Int] = self match {
    case Def(node: Q16GRPRecord1New) => node.P_SIZE
    case _                           => super.q16GRPRecord1_Field_P_SIZE(self)
  }
  override def q16GRPRecord1_Field_P_TYPE(self: Rep[Q16GRPRecord1]): Rep[OptimalString] = self match {
    case Def(node: Q16GRPRecord1New) => node.P_TYPE
    case _                           => super.q16GRPRecord1_Field_P_TYPE(self)
  }
  override def q16GRPRecord1_Field_P_BRAND(self: Rep[Q16GRPRecord1]): Rep[OptimalString] = self match {
    case Def(node: Q16GRPRecord1New) => node.P_BRAND
    case _                           => super.q16GRPRecord1_Field_P_BRAND(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q16GRPRecord1Component extends Q16GRPRecord1Ops with Q16GRPRecord1Implicits {}

trait Q16GRPRecord2Ops extends Base with OptimalStringOps {
  // Type representation
  case object Q16GRPRecord2Type extends TypeRep[Q16GRPRecord2] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q16GRPRecord2Type
    val name = "Q16GRPRecord2"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q16GRPRecord2]
  }
  implicit val typeQ16GRPRecord2 = Q16GRPRecord2Type
  implicit class Q16GRPRecord2Rep(self: Rep[Q16GRPRecord2]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q16GRPRecord2GetField(self, key)
    def P_SIZE: Rep[Int] = q16GRPRecord2_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = q16GRPRecord2_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = q16GRPRecord2_Field_P_BRAND(self)
  }
  object Q16GRPRecord2 {

  }
  // constructors
  def __newQ16GRPRecord2(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int]): Rep[Q16GRPRecord2] = q16GRPRecord2New(P_BRAND, P_TYPE, P_SIZE)
  // case classes
  case class Q16GRPRecord2New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int]) extends ConstructorDef[Q16GRPRecord2](List(), "Q16GRPRecord2", List(List(P_BRAND, P_TYPE, P_SIZE))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord2GetField(self: Rep[Q16GRPRecord2], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord2_Field_P_SIZE(self: Rep[Q16GRPRecord2]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord2_Field_P_TYPE(self: Rep[Q16GRPRecord2]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord2_Field_P_BRAND(self: Rep[Q16GRPRecord2]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q16GRPRecord2New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int]): Rep[Q16GRPRecord2] = Q16GRPRecord2New(P_BRAND, P_TYPE, P_SIZE)
  def q16GRPRecord2GetField(self: Rep[Q16GRPRecord2], key: Rep[String]): Rep[Option[Any]] = Q16GRPRecord2GetField(self, key)
  def q16GRPRecord2_Field_P_SIZE(self: Rep[Q16GRPRecord2]): Rep[Int] = Q16GRPRecord2_Field_P_SIZE(self)
  def q16GRPRecord2_Field_P_TYPE(self: Rep[Q16GRPRecord2]): Rep[OptimalString] = Q16GRPRecord2_Field_P_TYPE(self)
  def q16GRPRecord2_Field_P_BRAND(self: Rep[Q16GRPRecord2]): Rep[OptimalString] = Q16GRPRecord2_Field_P_BRAND(self)
  type Q16GRPRecord2 = ch.epfl.data.legobase.queryengine.Q16GRPRecord2
}
trait Q16GRPRecord2Implicits {
  // Add implicit conversions here!
}
trait Q16GRPRecord2Implementations {

}
trait Q16GRPRecord2PartialEvaluation extends Q16GRPRecord2Component with BasePartialEvaluation {
  // Immutable field inlining 
  override def q16GRPRecord2_Field_P_SIZE(self: Rep[Q16GRPRecord2]): Rep[Int] = self match {
    case Def(node: Q16GRPRecord2New) => node.P_SIZE
    case _                           => super.q16GRPRecord2_Field_P_SIZE(self)
  }
  override def q16GRPRecord2_Field_P_TYPE(self: Rep[Q16GRPRecord2]): Rep[OptimalString] = self match {
    case Def(node: Q16GRPRecord2New) => node.P_TYPE
    case _                           => super.q16GRPRecord2_Field_P_TYPE(self)
  }
  override def q16GRPRecord2_Field_P_BRAND(self: Rep[Q16GRPRecord2]): Rep[OptimalString] = self match {
    case Def(node: Q16GRPRecord2New) => node.P_BRAND
    case _                           => super.q16GRPRecord2_Field_P_BRAND(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q16GRPRecord2Component extends Q16GRPRecord2Ops with Q16GRPRecord2Implicits {}

trait Q18GRPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object Q18GRPRecordType extends TypeRep[Q18GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q18GRPRecordType
    val name = "Q18GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q18GRPRecord]
  }
  implicit val typeQ18GRPRecord = Q18GRPRecordType
  implicit class Q18GRPRecordRep(self: Rep[Q18GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q18GRPRecordGetField(self, key)
    def O_TOTALPRICE: Rep[Double] = q18GRPRecord_Field_O_TOTALPRICE(self)
    def O_ORDERDATE: Rep[Int] = q18GRPRecord_Field_O_ORDERDATE(self)
    def O_ORDERKEY: Rep[Int] = q18GRPRecord_Field_O_ORDERKEY(self)
    def C_CUSTKEY: Rep[Int] = q18GRPRecord_Field_C_CUSTKEY(self)
    def C_NAME: Rep[OptimalString] = q18GRPRecord_Field_C_NAME(self)
  }
  object Q18GRPRecord {

  }
  // constructors
  def __newQ18GRPRecord(C_NAME: Rep[OptimalString], C_CUSTKEY: Rep[Int], O_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Int], O_TOTALPRICE: Rep[Double]): Rep[Q18GRPRecord] = q18GRPRecordNew(C_NAME, C_CUSTKEY, O_ORDERKEY, O_ORDERDATE, O_TOTALPRICE)
  // case classes
  case class Q18GRPRecordNew(C_NAME: Rep[OptimalString], C_CUSTKEY: Rep[Int], O_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Int], O_TOTALPRICE: Rep[Double]) extends ConstructorDef[Q18GRPRecord](List(), "Q18GRPRecord", List(List(C_NAME, C_CUSTKEY, O_ORDERKEY, O_ORDERDATE, O_TOTALPRICE))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q18GRPRecordGetField(self: Rep[Q18GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q18GRPRecord_Field_O_TOTALPRICE(self: Rep[Q18GRPRecord]) extends FieldDef[Double](self, "O_TOTALPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_O_ORDERDATE(self: Rep[Q18GRPRecord]) extends FieldDef[Int](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_O_ORDERKEY(self: Rep[Q18GRPRecord]) extends FieldDef[Int](self, "O_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_C_CUSTKEY(self: Rep[Q18GRPRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_C_NAME(self: Rep[Q18GRPRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q18GRPRecordNew(C_NAME: Rep[OptimalString], C_CUSTKEY: Rep[Int], O_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Int], O_TOTALPRICE: Rep[Double]): Rep[Q18GRPRecord] = Q18GRPRecordNew(C_NAME, C_CUSTKEY, O_ORDERKEY, O_ORDERDATE, O_TOTALPRICE)
  def q18GRPRecordGetField(self: Rep[Q18GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q18GRPRecordGetField(self, key)
  def q18GRPRecord_Field_O_TOTALPRICE(self: Rep[Q18GRPRecord]): Rep[Double] = Q18GRPRecord_Field_O_TOTALPRICE(self)
  def q18GRPRecord_Field_O_ORDERDATE(self: Rep[Q18GRPRecord]): Rep[Int] = Q18GRPRecord_Field_O_ORDERDATE(self)
  def q18GRPRecord_Field_O_ORDERKEY(self: Rep[Q18GRPRecord]): Rep[Int] = Q18GRPRecord_Field_O_ORDERKEY(self)
  def q18GRPRecord_Field_C_CUSTKEY(self: Rep[Q18GRPRecord]): Rep[Int] = Q18GRPRecord_Field_C_CUSTKEY(self)
  def q18GRPRecord_Field_C_NAME(self: Rep[Q18GRPRecord]): Rep[OptimalString] = Q18GRPRecord_Field_C_NAME(self)
  type Q18GRPRecord = ch.epfl.data.legobase.queryengine.Q18GRPRecord
}
trait Q18GRPRecordImplicits {
  // Add implicit conversions here!
}
trait Q18GRPRecordImplementations {

}
trait Q18GRPRecordPartialEvaluation extends Q18GRPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def q18GRPRecord_Field_O_TOTALPRICE(self: Rep[Q18GRPRecord]): Rep[Double] = self match {
    case Def(node: Q18GRPRecordNew) => node.O_TOTALPRICE
    case _                          => super.q18GRPRecord_Field_O_TOTALPRICE(self)
  }
  override def q18GRPRecord_Field_O_ORDERDATE(self: Rep[Q18GRPRecord]): Rep[Int] = self match {
    case Def(node: Q18GRPRecordNew) => node.O_ORDERDATE
    case _                          => super.q18GRPRecord_Field_O_ORDERDATE(self)
  }
  override def q18GRPRecord_Field_O_ORDERKEY(self: Rep[Q18GRPRecord]): Rep[Int] = self match {
    case Def(node: Q18GRPRecordNew) => node.O_ORDERKEY
    case _                          => super.q18GRPRecord_Field_O_ORDERKEY(self)
  }
  override def q18GRPRecord_Field_C_CUSTKEY(self: Rep[Q18GRPRecord]): Rep[Int] = self match {
    case Def(node: Q18GRPRecordNew) => node.C_CUSTKEY
    case _                          => super.q18GRPRecord_Field_C_CUSTKEY(self)
  }
  override def q18GRPRecord_Field_C_NAME(self: Rep[Q18GRPRecord]): Rep[OptimalString] = self match {
    case Def(node: Q18GRPRecordNew) => node.C_NAME
    case _                          => super.q18GRPRecord_Field_C_NAME(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q18GRPRecordComponent extends Q18GRPRecordOps with Q18GRPRecordImplicits {}

trait Q20GRPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object Q20GRPRecordType extends TypeRep[Q20GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q20GRPRecordType
    val name = "Q20GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q20GRPRecord]
  }
  implicit val typeQ20GRPRecord = Q20GRPRecordType
  implicit class Q20GRPRecordRep(self: Rep[Q20GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q20GRPRecordGetField(self, key)
    def PS_AVAILQTY: Rep[Int] = q20GRPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = q20GRPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = q20GRPRecord_Field_PS_PARTKEY(self)
  }
  object Q20GRPRecord {

  }
  // constructors
  def __newQ20GRPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int]): Rep[Q20GRPRecord] = q20GRPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY)
  // case classes
  case class Q20GRPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int]) extends ConstructorDef[Q20GRPRecord](List(), "Q20GRPRecord", List(List(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q20GRPRecordGetField(self: Rep[Q20GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q20GRPRecord_Field_PS_AVAILQTY(self: Rep[Q20GRPRecord]) extends FieldDef[Int](self, "PS_AVAILQTY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q20GRPRecord_Field_PS_SUPPKEY(self: Rep[Q20GRPRecord]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q20GRPRecord_Field_PS_PARTKEY(self: Rep[Q20GRPRecord]) extends FieldDef[Int](self, "PS_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q20GRPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int]): Rep[Q20GRPRecord] = Q20GRPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY)
  def q20GRPRecordGetField(self: Rep[Q20GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q20GRPRecordGetField(self, key)
  def q20GRPRecord_Field_PS_AVAILQTY(self: Rep[Q20GRPRecord]): Rep[Int] = Q20GRPRecord_Field_PS_AVAILQTY(self)
  def q20GRPRecord_Field_PS_SUPPKEY(self: Rep[Q20GRPRecord]): Rep[Int] = Q20GRPRecord_Field_PS_SUPPKEY(self)
  def q20GRPRecord_Field_PS_PARTKEY(self: Rep[Q20GRPRecord]): Rep[Int] = Q20GRPRecord_Field_PS_PARTKEY(self)
  type Q20GRPRecord = ch.epfl.data.legobase.queryengine.Q20GRPRecord
}
trait Q20GRPRecordImplicits {
  // Add implicit conversions here!
}
trait Q20GRPRecordImplementations {

}
trait Q20GRPRecordPartialEvaluation extends Q20GRPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def q20GRPRecord_Field_PS_AVAILQTY(self: Rep[Q20GRPRecord]): Rep[Int] = self match {
    case Def(node: Q20GRPRecordNew) => node.PS_AVAILQTY
    case _                          => super.q20GRPRecord_Field_PS_AVAILQTY(self)
  }
  override def q20GRPRecord_Field_PS_SUPPKEY(self: Rep[Q20GRPRecord]): Rep[Int] = self match {
    case Def(node: Q20GRPRecordNew) => node.PS_SUPPKEY
    case _                          => super.q20GRPRecord_Field_PS_SUPPKEY(self)
  }
  override def q20GRPRecord_Field_PS_PARTKEY(self: Rep[Q20GRPRecord]): Rep[Int] = self match {
    case Def(node: Q20GRPRecordNew) => node.PS_PARTKEY
    case _                          => super.q20GRPRecord_Field_PS_PARTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait Q20GRPRecordComponent extends Q20GRPRecordOps with Q20GRPRecordImplicits {}

trait AGGRecordOps extends Base with OptimalStringOps {
  // Type representation
  case class AGGRecordType[B](typeB: TypeRep[B]) extends TypeRep[AGGRecord[B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = AGGRecordType(newArguments(0).asInstanceOf[TypeRep[_]])
    private implicit val tagB = typeB.typeTag
    val name = s"AGGRecord[${typeB.name}]"
    val typeArguments = List(typeB)
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[AGGRecord[B]]
  }
  implicit def typeAGGRecord[B: TypeRep] = AGGRecordType(implicitly[TypeRep[B]])
  implicit class AGGRecordRep[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = aGGRecordGetField[B](self, key)(typeB)
    def aggs: Rep[Array[Double]] = aGGRecord_Field_Aggs[B](self)(typeB)
    def key: Rep[B] = aGGRecord_Field_Key[B](self)(typeB)
  }
  object AGGRecord {

  }
  // constructors
  def __newAGGRecord[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = aGGRecordNew[B](key, aggs)(typeB)
  // case classes
  case class AGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit val typeB: TypeRep[B]) extends ConstructorDef[AGGRecord[B]](List(typeB), "AGGRecord", List(List(key, aggs))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit val typeB: TypeRep[B]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[Array[Double]](self, "aggs") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

  }

  case class AGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

  }

  // method definitions
  def aGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = AGGRecordNew[B](key, aggs)
  def aGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit typeB: TypeRep[B]): Rep[Option[Any]] = AGGRecordGetField[B](self, key)
  def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[Array[Double]] = AGGRecord_Field_Aggs[B](self)
  def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[B] = AGGRecord_Field_Key[B](self)
  type AGGRecord[B] = ch.epfl.data.legobase.queryengine.AGGRecord[B]
}
trait AGGRecordImplicits {
  // Add implicit conversions here!
}
trait AGGRecordImplementations {

}
trait AGGRecordPartialEvaluation extends AGGRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[Array[Double]] = self match {
    case Def(node: AGGRecordNew[_]) => node.aggs
    case _                          => super.aGGRecord_Field_Aggs[B](self)(typeB)
  }
  override def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[B] = self match {
    case Def(node: AGGRecordNew[_]) => node.key
    case _                          => super.aGGRecord_Field_Key[B](self)(typeB)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait AGGRecordComponent extends AGGRecordOps with AGGRecordImplicits {}

trait GenericEngineOps extends Base with OptimalStringOps {
  // Type representation
  case object GenericEngineType extends TypeRep[GenericEngine] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = GenericEngineType
    val name = "GenericEngine"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[GenericEngine]
  }
  implicit val typeGenericEngine = GenericEngineType
  implicit class GenericEngineRep(self: Rep[GenericEngine]) {

  }
  object GenericEngine {
    def runQuery[T](query: => Rep[T])(implicit typeT: TypeRep[T]): Rep[T] = genericEngineRunQueryObject[T](query)(typeT)
    def dateToString(long: Rep[Int]): Rep[String] = genericEngineDateToStringObject(long)
    def dateToYear(long: Rep[Int]): Rep[Int] = genericEngineDateToYearObject(long)
    def parseDate(x: Rep[String]): Rep[Int] = genericEngineParseDateObject(x)
    def parseString(x: Rep[String]): Rep[OptimalString] = genericEngineParseStringObject(x)
  }
  // constructors

  // case classes
  case class GenericEngineRunQueryObject[T](queryOutput: Block[T])(implicit val typeT: TypeRep[T]) extends FunctionDef[T](None, "GenericEngine.runQuery", List(List(queryOutput))) {
    override def curriedConstructor = (copy[T] _)
  }

  case class GenericEngineDateToStringObject(long: Rep[Int]) extends FunctionDef[String](None, "GenericEngine.dateToString", List(List(long))) {
    override def curriedConstructor = (copy _)
  }

  case class GenericEngineDateToYearObject(long: Rep[Int]) extends FunctionDef[Int](None, "GenericEngine.dateToYear", List(List(long))) {
    override def curriedConstructor = (copy _)
  }

  case class GenericEngineParseDateObject(x: Rep[String]) extends FunctionDef[Int](None, "GenericEngine.parseDate", List(List(x))) {
    override def curriedConstructor = (copy _)
  }

  case class GenericEngineParseStringObject(x: Rep[String]) extends FunctionDef[OptimalString](None, "GenericEngine.parseString", List(List(x))) {
    override def curriedConstructor = (copy _)
  }

  // method definitions
  def genericEngineRunQueryObject[T](query: => Rep[T])(implicit typeT: TypeRep[T]): Rep[T] = {
    val queryOutput = reifyBlock(query)
    GenericEngineRunQueryObject[T](queryOutput)
  }
  def genericEngineDateToStringObject(long: Rep[Int]): Rep[String] = GenericEngineDateToStringObject(long)
  def genericEngineDateToYearObject(long: Rep[Int]): Rep[Int] = GenericEngineDateToYearObject(long)
  def genericEngineParseDateObject(x: Rep[String]): Rep[Int] = GenericEngineParseDateObject(x)
  def genericEngineParseStringObject(x: Rep[String]): Rep[OptimalString] = GenericEngineParseStringObject(x)
  type GenericEngine = ch.epfl.data.legobase.queryengine.GenericEngine
}
trait GenericEngineImplicits {
  // Add implicit conversions here!
}
trait GenericEngineImplementations {

}
trait GenericEnginePartialEvaluation extends GenericEngineComponent with BasePartialEvaluation {
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait GenericEngineComponent extends GenericEngineOps with GenericEngineImplicits {}

trait LINEITEMRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object LINEITEMRecordType extends TypeRep[LINEITEMRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = LINEITEMRecordType
    val name = "LINEITEMRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[LINEITEMRecord]
  }
  implicit val typeLINEITEMRecord = LINEITEMRecordType
  implicit class LINEITEMRecordRep(self: Rep[LINEITEMRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = lINEITEMRecordGetField(self, key)
    def L_COMMENT: Rep[OptimalString] = lINEITEMRecord_Field_L_COMMENT(self)
    def L_SHIPMODE: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPMODE(self)
    def L_SHIPINSTRUCT: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
    def L_RECEIPTDATE: Rep[Int] = lINEITEMRecord_Field_L_RECEIPTDATE(self)
    def L_COMMITDATE: Rep[Int] = lINEITEMRecord_Field_L_COMMITDATE(self)
    def L_SHIPDATE: Rep[Int] = lINEITEMRecord_Field_L_SHIPDATE(self)
    def L_LINESTATUS: Rep[Char] = lINEITEMRecord_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Char] = lINEITEMRecord_Field_L_RETURNFLAG(self)
    def L_TAX: Rep[Double] = lINEITEMRecord_Field_L_TAX(self)
    def L_DISCOUNT: Rep[Double] = lINEITEMRecord_Field_L_DISCOUNT(self)
    def L_EXTENDEDPRICE: Rep[Double] = lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
    def L_QUANTITY: Rep[Double] = lINEITEMRecord_Field_L_QUANTITY(self)
    def L_LINENUMBER: Rep[Int] = lINEITEMRecord_Field_L_LINENUMBER(self)
    def L_SUPPKEY: Rep[Int] = lINEITEMRecord_Field_L_SUPPKEY(self)
    def L_PARTKEY: Rep[Int] = lINEITEMRecord_Field_L_PARTKEY(self)
    def L_ORDERKEY: Rep[Int] = lINEITEMRecord_Field_L_ORDERKEY(self)
  }
  object LINEITEMRecord {

  }
  // constructors
  def __newLINEITEMRecord(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  // case classes
  case class LINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]) extends ConstructorDef[LINEITEMRecord](List(), "LINEITEMRecord", List(List(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPMODE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPINSTRUCT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_RECEIPTDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_COMMITDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_SHIPDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]) extends FieldDef[Char](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]) extends FieldDef[Char](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_TAX") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_DISCOUNT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_EXTENDEDPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_QUANTITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_LINENUMBER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def lINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = LINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  def lINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]): Rep[Option[Any]] = LINEITEMRecordGetField(self, key)
  def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_COMMENT(self)
  def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPMODE(self)
  def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPINSTRUCT(self)
  def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_RECEIPTDATE(self)
  def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_COMMITDATE(self)
  def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SHIPDATE(self)
  def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Char] = LINEITEMRecord_Field_L_LINESTATUS(self)
  def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Char] = LINEITEMRecord_Field_L_RETURNFLAG(self)
  def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_TAX(self)
  def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_DISCOUNT(self)
  def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_EXTENDEDPRICE(self)
  def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_QUANTITY(self)
  def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_LINENUMBER(self)
  def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SUPPKEY(self)
  def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_PARTKEY(self)
  def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_ORDERKEY(self)
  type LINEITEMRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.LINEITEMRecord
}
trait LINEITEMRecordImplicits {
  // Add implicit conversions here!
}
trait LINEITEMRecordImplementations {

}
trait LINEITEMRecordPartialEvaluation extends LINEITEMRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_COMMENT
    case _                            => super.lINEITEMRecord_Field_L_COMMENT(self)
  }
  override def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SHIPMODE
    case _                            => super.lINEITEMRecord_Field_L_SHIPMODE(self)
  }
  override def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SHIPINSTRUCT
    case _                            => super.lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
  }
  override def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_RECEIPTDATE
    case _                            => super.lINEITEMRecord_Field_L_RECEIPTDATE(self)
  }
  override def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_COMMITDATE
    case _                            => super.lINEITEMRecord_Field_L_COMMITDATE(self)
  }
  override def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SHIPDATE
    case _                            => super.lINEITEMRecord_Field_L_SHIPDATE(self)
  }
  override def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Char] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_LINESTATUS
    case _                            => super.lINEITEMRecord_Field_L_LINESTATUS(self)
  }
  override def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Char] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_RETURNFLAG
    case _                            => super.lINEITEMRecord_Field_L_RETURNFLAG(self)
  }
  override def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_TAX
    case _                            => super.lINEITEMRecord_Field_L_TAX(self)
  }
  override def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_DISCOUNT
    case _                            => super.lINEITEMRecord_Field_L_DISCOUNT(self)
  }
  override def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_EXTENDEDPRICE
    case _                            => super.lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
  }
  override def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_QUANTITY
    case _                            => super.lINEITEMRecord_Field_L_QUANTITY(self)
  }
  override def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_LINENUMBER
    case _                            => super.lINEITEMRecord_Field_L_LINENUMBER(self)
  }
  override def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SUPPKEY
    case _                            => super.lINEITEMRecord_Field_L_SUPPKEY(self)
  }
  override def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_PARTKEY
    case _                            => super.lINEITEMRecord_Field_L_PARTKEY(self)
  }
  override def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_ORDERKEY
    case _                            => super.lINEITEMRecord_Field_L_ORDERKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait LINEITEMRecordComponent extends LINEITEMRecordOps with LINEITEMRecordImplicits {}

trait SUPPLIERRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object SUPPLIERRecordType extends TypeRep[SUPPLIERRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = SUPPLIERRecordType
    val name = "SUPPLIERRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[SUPPLIERRecord]
  }
  implicit val typeSUPPLIERRecord = SUPPLIERRecordType
  implicit class SUPPLIERRecordRep(self: Rep[SUPPLIERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = sUPPLIERRecordGetField(self, key)
    def S_COMMENT: Rep[OptimalString] = sUPPLIERRecord_Field_S_COMMENT(self)
    def S_ACCTBAL: Rep[Double] = sUPPLIERRecord_Field_S_ACCTBAL(self)
    def S_PHONE: Rep[OptimalString] = sUPPLIERRecord_Field_S_PHONE(self)
    def S_NATIONKEY: Rep[Int] = sUPPLIERRecord_Field_S_NATIONKEY(self)
    def S_ADDRESS: Rep[OptimalString] = sUPPLIERRecord_Field_S_ADDRESS(self)
    def S_NAME: Rep[OptimalString] = sUPPLIERRecord_Field_S_NAME(self)
    def S_SUPPKEY: Rep[Int] = sUPPLIERRecord_Field_S_SUPPKEY(self)
  }
  object SUPPLIERRecord {

  }
  // constructors
  def __newSUPPLIERRecord(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  // case classes
  case class SUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]) extends ConstructorDef[SUPPLIERRecord](List(), "SUPPLIERRecord", List(List(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]) extends FieldDef[Double](self, "S_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def sUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = SUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  def sUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]): Rep[Option[Any]] = SUPPLIERRecordGetField(self, key)
  def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_COMMENT(self)
  def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = SUPPLIERRecord_Field_S_ACCTBAL(self)
  def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_PHONE(self)
  def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_NATIONKEY(self)
  def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_ADDRESS(self)
  def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_NAME(self)
  def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_SUPPKEY(self)
  type SUPPLIERRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.SUPPLIERRecord
}
trait SUPPLIERRecordImplicits {
  // Add implicit conversions here!
}
trait SUPPLIERRecordImplementations {

}
trait SUPPLIERRecordPartialEvaluation extends SUPPLIERRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_COMMENT
    case _                            => super.sUPPLIERRecord_Field_S_COMMENT(self)
  }
  override def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_ACCTBAL
    case _                            => super.sUPPLIERRecord_Field_S_ACCTBAL(self)
  }
  override def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_PHONE
    case _                            => super.sUPPLIERRecord_Field_S_PHONE(self)
  }
  override def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_NATIONKEY
    case _                            => super.sUPPLIERRecord_Field_S_NATIONKEY(self)
  }
  override def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_ADDRESS
    case _                            => super.sUPPLIERRecord_Field_S_ADDRESS(self)
  }
  override def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_NAME
    case _                            => super.sUPPLIERRecord_Field_S_NAME(self)
  }
  override def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_SUPPKEY
    case _                            => super.sUPPLIERRecord_Field_S_SUPPKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait SUPPLIERRecordComponent extends SUPPLIERRecordOps with SUPPLIERRecordImplicits {}

trait PARTSUPPRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object PARTSUPPRecordType extends TypeRep[PARTSUPPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PARTSUPPRecordType
    val name = "PARTSUPPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[PARTSUPPRecord]
  }
  implicit val typePARTSUPPRecord = PARTSUPPRecordType
  implicit class PARTSUPPRecordRep(self: Rep[PARTSUPPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTSUPPRecordGetField(self, key)
    def PS_COMMENT: Rep[OptimalString] = pARTSUPPRecord_Field_PS_COMMENT(self)
    def PS_SUPPLYCOST: Rep[Double] = pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
    def PS_AVAILQTY: Rep[Int] = pARTSUPPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = pARTSUPPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = pARTSUPPRecord_Field_PS_PARTKEY(self)
  }
  object PARTSUPPRecord {

  }
  // constructors
  def __newPARTSUPPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  // case classes
  case class PARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTSUPPRecord](List(), "PARTSUPPRecord", List(List(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]) extends FieldDef[OptimalString](self, "PS_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]) extends FieldDef[Double](self, "PS_SUPPLYCOST") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_AVAILQTY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def pARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = PARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  def pARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]): Rep[Option[Any]] = PARTSUPPRecordGetField(self, key)
  def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = PARTSUPPRecord_Field_PS_COMMENT(self)
  def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = PARTSUPPRecord_Field_PS_SUPPLYCOST(self)
  def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_AVAILQTY(self)
  def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_SUPPKEY(self)
  def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_PARTKEY(self)
  type PARTSUPPRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.PARTSUPPRecord
}
trait PARTSUPPRecordImplicits {
  // Add implicit conversions here!
}
trait PARTSUPPRecordImplementations {

}
trait PARTSUPPRecordPartialEvaluation extends PARTSUPPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_COMMENT
    case _                            => super.pARTSUPPRecord_Field_PS_COMMENT(self)
  }
  override def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_SUPPLYCOST
    case _                            => super.pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
  }
  override def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_AVAILQTY
    case _                            => super.pARTSUPPRecord_Field_PS_AVAILQTY(self)
  }
  override def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_SUPPKEY
    case _                            => super.pARTSUPPRecord_Field_PS_SUPPKEY(self)
  }
  override def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_PARTKEY
    case _                            => super.pARTSUPPRecord_Field_PS_PARTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait PARTSUPPRecordComponent extends PARTSUPPRecordOps with PARTSUPPRecordImplicits {}

trait REGIONRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object REGIONRecordType extends TypeRep[REGIONRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = REGIONRecordType
    val name = "REGIONRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[REGIONRecord]
  }
  implicit val typeREGIONRecord = REGIONRecordType
  implicit class REGIONRecordRep(self: Rep[REGIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = rEGIONRecordGetField(self, key)
    def R_COMMENT: Rep[OptimalString] = rEGIONRecord_Field_R_COMMENT(self)
    def R_NAME: Rep[OptimalString] = rEGIONRecord_Field_R_NAME(self)
    def R_REGIONKEY: Rep[Int] = rEGIONRecord_Field_R_REGIONKEY(self)
  }
  object REGIONRecord {

  }
  // constructors
  def __newREGIONRecord(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  // case classes
  case class REGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]) extends ConstructorDef[REGIONRecord](List(), "REGIONRecord", List(List(R_REGIONKEY, R_NAME, R_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class REGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class REGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]) extends FieldDef[Int](self, "R_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def rEGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = REGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  def rEGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]): Rep[Option[Any]] = REGIONRecordGetField(self, key)
  def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_COMMENT(self)
  def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_NAME(self)
  def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = REGIONRecord_Field_R_REGIONKEY(self)
  type REGIONRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.REGIONRecord
}
trait REGIONRecordImplicits {
  // Add implicit conversions here!
}
trait REGIONRecordImplementations {

}
trait REGIONRecordPartialEvaluation extends REGIONRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = self match {
    case Def(node: REGIONRecordNew) => node.R_COMMENT
    case _                          => super.rEGIONRecord_Field_R_COMMENT(self)
  }
  override def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = self match {
    case Def(node: REGIONRecordNew) => node.R_NAME
    case _                          => super.rEGIONRecord_Field_R_NAME(self)
  }
  override def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = self match {
    case Def(node: REGIONRecordNew) => node.R_REGIONKEY
    case _                          => super.rEGIONRecord_Field_R_REGIONKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait REGIONRecordComponent extends REGIONRecordOps with REGIONRecordImplicits {}

trait NATIONRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object NATIONRecordType extends TypeRep[NATIONRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = NATIONRecordType
    val name = "NATIONRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[NATIONRecord]
  }
  implicit val typeNATIONRecord = NATIONRecordType
  implicit class NATIONRecordRep(self: Rep[NATIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = nATIONRecordGetField(self, key)
    def N_COMMENT: Rep[OptimalString] = nATIONRecord_Field_N_COMMENT(self)
    def N_REGIONKEY: Rep[Int] = nATIONRecord_Field_N_REGIONKEY(self)
    def N_NAME: Rep[OptimalString] = nATIONRecord_Field_N_NAME(self)
    def N_NATIONKEY: Rep[Int] = nATIONRecord_Field_N_NATIONKEY(self)
  }
  object NATIONRecord {

  }
  // constructors
  def __newNATIONRecord(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  // case classes
  case class NATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]) extends ConstructorDef[NATIONRecord](List(), "NATIONRecord", List(List(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def nATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = NATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  def nATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]): Rep[Option[Any]] = NATIONRecordGetField(self, key)
  def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_COMMENT(self)
  def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_REGIONKEY(self)
  def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_NAME(self)
  def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_NATIONKEY(self)
  type NATIONRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.NATIONRecord
}
trait NATIONRecordImplicits {
  // Add implicit conversions here!
}
trait NATIONRecordImplementations {

}
trait NATIONRecordPartialEvaluation extends NATIONRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = self match {
    case Def(node: NATIONRecordNew) => node.N_COMMENT
    case _                          => super.nATIONRecord_Field_N_COMMENT(self)
  }
  override def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = self match {
    case Def(node: NATIONRecordNew) => node.N_REGIONKEY
    case _                          => super.nATIONRecord_Field_N_REGIONKEY(self)
  }
  override def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = self match {
    case Def(node: NATIONRecordNew) => node.N_NAME
    case _                          => super.nATIONRecord_Field_N_NAME(self)
  }
  override def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = self match {
    case Def(node: NATIONRecordNew) => node.N_NATIONKEY
    case _                          => super.nATIONRecord_Field_N_NATIONKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait NATIONRecordComponent extends NATIONRecordOps with NATIONRecordImplicits {}

trait PARTRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object PARTRecordType extends TypeRep[PARTRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PARTRecordType
    val name = "PARTRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[PARTRecord]
  }
  implicit val typePARTRecord = PARTRecordType
  implicit class PARTRecordRep(self: Rep[PARTRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTRecordGetField(self, key)
    def P_COMMENT: Rep[OptimalString] = pARTRecord_Field_P_COMMENT(self)
    def P_RETAILPRICE: Rep[Double] = pARTRecord_Field_P_RETAILPRICE(self)
    def P_CONTAINER: Rep[OptimalString] = pARTRecord_Field_P_CONTAINER(self)
    def P_SIZE: Rep[Int] = pARTRecord_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = pARTRecord_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = pARTRecord_Field_P_BRAND(self)
    def P_MFGR: Rep[OptimalString] = pARTRecord_Field_P_MFGR(self)
    def P_NAME: Rep[OptimalString] = pARTRecord_Field_P_NAME(self)
    def P_PARTKEY: Rep[Int] = pARTRecord_Field_P_PARTKEY(self)
  }
  object PARTRecord {

  }
  // constructors
  def __newPARTRecord(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  // case classes
  case class PARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTRecord](List(), "PARTRecord", List(List(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]) extends FieldDef[Double](self, "P_RETAILPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_CONTAINER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_SIZE(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_TYPE(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_BRAND(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_MFGR(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_MFGR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_NAME(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def pARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = PARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  def pARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]): Rep[Option[Any]] = PARTRecordGetField(self, key)
  def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_COMMENT(self)
  def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = PARTRecord_Field_P_RETAILPRICE(self)
  def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_CONTAINER(self)
  def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_SIZE(self)
  def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_TYPE(self)
  def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_BRAND(self)
  def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_MFGR(self)
  def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_NAME(self)
  def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_PARTKEY(self)
  type PARTRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.PARTRecord
}
trait PARTRecordImplicits {
  // Add implicit conversions here!
}
trait PARTRecordImplementations {

}
trait PARTRecordPartialEvaluation extends PARTRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_COMMENT
    case _                        => super.pARTRecord_Field_P_COMMENT(self)
  }
  override def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = self match {
    case Def(node: PARTRecordNew) => node.P_RETAILPRICE
    case _                        => super.pARTRecord_Field_P_RETAILPRICE(self)
  }
  override def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_CONTAINER
    case _                        => super.pARTRecord_Field_P_CONTAINER(self)
  }
  override def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = self match {
    case Def(node: PARTRecordNew) => node.P_SIZE
    case _                        => super.pARTRecord_Field_P_SIZE(self)
  }
  override def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_TYPE
    case _                        => super.pARTRecord_Field_P_TYPE(self)
  }
  override def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_BRAND
    case _                        => super.pARTRecord_Field_P_BRAND(self)
  }
  override def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_MFGR
    case _                        => super.pARTRecord_Field_P_MFGR(self)
  }
  override def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_NAME
    case _                        => super.pARTRecord_Field_P_NAME(self)
  }
  override def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = self match {
    case Def(node: PARTRecordNew) => node.P_PARTKEY
    case _                        => super.pARTRecord_Field_P_PARTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait PARTRecordComponent extends PARTRecordOps with PARTRecordImplicits {}

trait CUSTOMERRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object CUSTOMERRecordType extends TypeRep[CUSTOMERRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = CUSTOMERRecordType
    val name = "CUSTOMERRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[CUSTOMERRecord]
  }
  implicit val typeCUSTOMERRecord = CUSTOMERRecordType
  implicit class CUSTOMERRecordRep(self: Rep[CUSTOMERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = cUSTOMERRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_COMMENT(self)
    def C_MKTSEGMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_MKTSEGMENT(self)
    def C_ACCTBAL: Rep[Double] = cUSTOMERRecord_Field_C_ACCTBAL(self)
    def C_PHONE: Rep[OptimalString] = cUSTOMERRecord_Field_C_PHONE(self)
    def C_NATIONKEY: Rep[Int] = cUSTOMERRecord_Field_C_NATIONKEY(self)
    def C_ADDRESS: Rep[OptimalString] = cUSTOMERRecord_Field_C_ADDRESS(self)
    def C_NAME: Rep[OptimalString] = cUSTOMERRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = cUSTOMERRecord_Field_C_CUSTKEY(self)
  }
  object CUSTOMERRecord {

  }
  // constructors
  def __newCUSTOMERRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  // case classes
  case class CUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends ConstructorDef[CUSTOMERRecord](List(), "CUSTOMERRecord", List(List(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_MKTSEGMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]) extends FieldDef[Double](self, "C_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def cUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = CUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  def cUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]): Rep[Option[Any]] = CUSTOMERRecordGetField(self, key)
  def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_COMMENT(self)
  def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_MKTSEGMENT(self)
  def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = CUSTOMERRecord_Field_C_ACCTBAL(self)
  def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_PHONE(self)
  def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_NATIONKEY(self)
  def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_ADDRESS(self)
  def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_NAME(self)
  def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_CUSTKEY(self)
  type CUSTOMERRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.CUSTOMERRecord
}
trait CUSTOMERRecordImplicits {
  // Add implicit conversions here!
}
trait CUSTOMERRecordImplementations {

}
trait CUSTOMERRecordPartialEvaluation extends CUSTOMERRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_COMMENT
    case _                            => super.cUSTOMERRecord_Field_C_COMMENT(self)
  }
  override def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_MKTSEGMENT
    case _                            => super.cUSTOMERRecord_Field_C_MKTSEGMENT(self)
  }
  override def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_ACCTBAL
    case _                            => super.cUSTOMERRecord_Field_C_ACCTBAL(self)
  }
  override def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_PHONE
    case _                            => super.cUSTOMERRecord_Field_C_PHONE(self)
  }
  override def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_NATIONKEY
    case _                            => super.cUSTOMERRecord_Field_C_NATIONKEY(self)
  }
  override def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_ADDRESS
    case _                            => super.cUSTOMERRecord_Field_C_ADDRESS(self)
  }
  override def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_NAME
    case _                            => super.cUSTOMERRecord_Field_C_NAME(self)
  }
  override def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_CUSTKEY
    case _                            => super.cUSTOMERRecord_Field_C_CUSTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait CUSTOMERRecordComponent extends CUSTOMERRecordOps with CUSTOMERRecordImplicits {}

trait ORDERSRecordOps extends Base with OptimalStringOps {
  // Type representation
  case object ORDERSRecordType extends TypeRep[ORDERSRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ORDERSRecordType
    val name = "ORDERSRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[ORDERSRecord]
  }
  implicit val typeORDERSRecord = ORDERSRecordType
  implicit class ORDERSRecordRep(self: Rep[ORDERSRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = oRDERSRecordGetField(self, key)
    def O_COMMENT: Rep[OptimalString] = oRDERSRecord_Field_O_COMMENT(self)
    def O_SHIPPRIORITY: Rep[Int] = oRDERSRecord_Field_O_SHIPPRIORITY(self)
    def O_CLERK: Rep[OptimalString] = oRDERSRecord_Field_O_CLERK(self)
    def O_ORDERPRIORITY: Rep[OptimalString] = oRDERSRecord_Field_O_ORDERPRIORITY(self)
    def O_ORDERDATE: Rep[Int] = oRDERSRecord_Field_O_ORDERDATE(self)
    def O_TOTALPRICE: Rep[Double] = oRDERSRecord_Field_O_TOTALPRICE(self)
    def O_ORDERSTATUS: Rep[Char] = oRDERSRecord_Field_O_ORDERSTATUS(self)
    def O_CUSTKEY: Rep[Int] = oRDERSRecord_Field_O_CUSTKEY(self)
    def O_ORDERKEY: Rep[Int] = oRDERSRecord_Field_O_ORDERKEY(self)
  }
  object ORDERSRecord {

  }
  // constructors
  def __newORDERSRecord(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  // case classes
  case class ORDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]) extends ConstructorDef[ORDERSRecord](List(), "ORDERSRecord", List(List(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_CLERK") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_ORDERPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]) extends FieldDef[Double](self, "O_TOTALPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]) extends FieldDef[Char](self, "O_ORDERSTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def oRDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = ORDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  def oRDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]): Rep[Option[Any]] = ORDERSRecordGetField(self, key)
  def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_COMMENT(self)
  def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_SHIPPRIORITY(self)
  def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_CLERK(self)
  def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_ORDERPRIORITY(self)
  def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERDATE(self)
  def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = ORDERSRecord_Field_O_TOTALPRICE(self)
  def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Char] = ORDERSRecord_Field_O_ORDERSTATUS(self)
  def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_CUSTKEY(self)
  def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERKEY(self)
  type ORDERSRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.ORDERSRecord
}
trait ORDERSRecordImplicits {
  // Add implicit conversions here!
}
trait ORDERSRecordImplementations {

}
trait ORDERSRecordPartialEvaluation extends ORDERSRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = self match {
    case Def(node: ORDERSRecordNew) => node.O_COMMENT
    case _                          => super.oRDERSRecord_Field_O_COMMENT(self)
  }
  override def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_SHIPPRIORITY
    case _                          => super.oRDERSRecord_Field_O_SHIPPRIORITY(self)
  }
  override def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = self match {
    case Def(node: ORDERSRecordNew) => node.O_CLERK
    case _                          => super.oRDERSRecord_Field_O_CLERK(self)
  }
  override def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERPRIORITY
    case _                          => super.oRDERSRecord_Field_O_ORDERPRIORITY(self)
  }
  override def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERDATE
    case _                          => super.oRDERSRecord_Field_O_ORDERDATE(self)
  }
  override def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = self match {
    case Def(node: ORDERSRecordNew) => node.O_TOTALPRICE
    case _                          => super.oRDERSRecord_Field_O_TOTALPRICE(self)
  }
  override def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Char] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERSTATUS
    case _                          => super.oRDERSRecord_Field_O_ORDERSTATUS(self)
  }
  override def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_CUSTKEY
    case _                          => super.oRDERSRecord_Field_O_CUSTKEY(self)
  }
  override def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERKEY
    case _                          => super.oRDERSRecord_Field_O_ORDERKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait ORDERSRecordComponent extends ORDERSRecordOps with ORDERSRecordImplicits {}

trait NextContainerOps extends Base with OptimalStringOps {
  // Type representation
  case class NextContainerType[T](typeT: TypeRep[T]) extends TypeRep[NextContainer[T]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = NextContainerType(newArguments(0).asInstanceOf[TypeRep[_]])
    private implicit val tagT = typeT.typeTag
    val name = s"NextContainer[${typeT.name}]"
    val typeArguments = List(typeT)

    val typeTag = scala.reflect.runtime.universe.typeTag[NextContainer[T]]
  }
  implicit def typeNextContainer[T: TypeRep] = NextContainerType(implicitly[TypeRep[T]])
  implicit class NextContainerRep[T](self: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]) {
    def next_=(x$1: Rep[NextContainer[T]]): Rep[Unit] = nextContainer_Field_Next_$eq[T](self, x$1)(typeT)
    def next: Rep[NextContainer[T]] = nextContainer_Field_Next[T](self)(typeT)
    def current: Rep[T] = nextContainer_Field_Current[T](self)(typeT)
  }
  object NextContainer {

  }
  // constructors
  def __newNextContainer[T](current: Rep[T], next: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]): Rep[NextContainer[T]] = nextContainerNew[T](current, next)(typeT)
  // case classes
  case class NextContainerNew[T](current: Rep[T], next: Rep[NextContainer[T]])(implicit val typeT: TypeRep[T]) extends ConstructorDef[NextContainer[T]](List(typeT), "NextContainer", List(List(current, next))) {
    override def curriedConstructor = (copy[T] _).curried
  }

  case class NextContainer_Field_Next_$eq[T](self: Rep[NextContainer[T]], x$1: Rep[NextContainer[T]])(implicit val typeT: TypeRep[T]) extends FieldSetter[NextContainer[T]](self, "next", x$1) {
    override def curriedConstructor = (copy[T] _).curried
  }

  case class NextContainer_Field_Next[T](self: Rep[NextContainer[T]])(implicit val typeT: TypeRep[T]) extends FieldGetter[NextContainer[T]](self, "next") {
    override def curriedConstructor = (copy[T] _)
  }

  case class NextContainer_Field_Current[T](self: Rep[NextContainer[T]])(implicit val typeT: TypeRep[T]) extends FieldDef[T](self, "current") {
    override def curriedConstructor = (copy[T] _)
    override def isPure = true

  }

  // method definitions
  def nextContainerNew[T](current: Rep[T], next: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]): Rep[NextContainer[T]] = NextContainerNew[T](current, next)
  def nextContainer_Field_Next_$eq[T](self: Rep[NextContainer[T]], x$1: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]): Rep[Unit] = NextContainer_Field_Next_$eq[T](self, x$1)
  def nextContainer_Field_Next[T](self: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]): Rep[NextContainer[T]] = NextContainer_Field_Next[T](self)
  def nextContainer_Field_Current[T](self: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]): Rep[T] = NextContainer_Field_Current[T](self)
  type NextContainer[T] = ch.epfl.data.legobase.NextContainer[T]
}
trait NextContainerImplicits {
  // Add implicit conversions here!
}
trait NextContainerImplementations {

}
trait NextContainerPartialEvaluation extends NextContainerComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def nextContainer_Field_Current[T](self: Rep[NextContainer[T]])(implicit typeT: TypeRep[T]): Rep[T] = self match {
    case Def(node: NextContainerNew[_]) => node.current
    case _                              => super.nextContainer_Field_Current[T](self)(typeT)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait NextContainerComponent extends NextContainerOps with NextContainerImplicits {}

trait NextKeyContainerOps extends Base with OptimalStringOps {
  // Type representation
  case class NextKeyContainerType[K, T](typeK: TypeRep[K], typeT: TypeRep[T]) extends TypeRep[NextKeyContainer[K, T]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = NextKeyContainerType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    private implicit val tagK = typeK.typeTag
    private implicit val tagT = typeT.typeTag
    val name = s"NextKeyContainer[${typeK.name}, ${typeT.name}]"
    val typeArguments = List(typeK, typeT)

    val typeTag = scala.reflect.runtime.universe.typeTag[NextKeyContainer[K, T]]
  }
  implicit def typeNextKeyContainer[K: TypeRep, T: TypeRep] = NextKeyContainerType(implicitly[TypeRep[K]], implicitly[TypeRep[T]])
  implicit class NextKeyContainerRep[K, T](self: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]) {
    def next_=(x$1: Rep[NextKeyContainer[K, T]]): Rep[Unit] = nextKeyContainer_Field_Next_$eq[K, T](self, x$1)(typeK, typeT)
    def next: Rep[NextKeyContainer[K, T]] = nextKeyContainer_Field_Next[K, T](self)(typeK, typeT)
    def key_=(x$1: Rep[K]): Rep[Unit] = nextKeyContainer_Field_Key_$eq[K, T](self, x$1)(typeK, typeT)
    def key: Rep[K] = nextKeyContainer_Field_Key[K, T](self)(typeK, typeT)
    def current: Rep[T] = nextKeyContainer_Field_Current[K, T](self)(typeK, typeT)
  }
  object NextKeyContainer {

  }
  // constructors
  def __newNextKeyContainer[K, T](current: Rep[T], key: Rep[K], next: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[NextKeyContainer[K, T]] = nextKeyContainerNew[K, T](current, key, next)(typeK, typeT)
  // case classes
  case class NextKeyContainerNew[K, T](current: Rep[T], key: Rep[K], next: Rep[NextKeyContainer[K, T]])(implicit val typeK: TypeRep[K], val typeT: TypeRep[T]) extends ConstructorDef[NextKeyContainer[K, T]](List(typeK, typeT), "NextKeyContainer", List(List(current, key, next))) {
    override def curriedConstructor = (copy[K, T] _).curried
  }

  case class NextKeyContainer_Field_Next_$eq[K, T](self: Rep[NextKeyContainer[K, T]], x$1: Rep[NextKeyContainer[K, T]])(implicit val typeK: TypeRep[K], val typeT: TypeRep[T]) extends FieldSetter[NextKeyContainer[K, T]](self, "next", x$1) {
    override def curriedConstructor = (copy[K, T] _).curried
  }

  case class NextKeyContainer_Field_Next[K, T](self: Rep[NextKeyContainer[K, T]])(implicit val typeK: TypeRep[K], val typeT: TypeRep[T]) extends FieldGetter[NextKeyContainer[K, T]](self, "next") {
    override def curriedConstructor = (copy[K, T] _)
  }

  case class NextKeyContainer_Field_Key_$eq[K, T](self: Rep[NextKeyContainer[K, T]], x$1: Rep[K])(implicit val typeK: TypeRep[K], val typeT: TypeRep[T]) extends FieldSetter[K](self, "key", x$1) {
    override def curriedConstructor = (copy[K, T] _).curried
  }

  case class NextKeyContainer_Field_Key[K, T](self: Rep[NextKeyContainer[K, T]])(implicit val typeK: TypeRep[K], val typeT: TypeRep[T]) extends FieldGetter[K](self, "key") {
    override def curriedConstructor = (copy[K, T] _)
  }

  case class NextKeyContainer_Field_Current[K, T](self: Rep[NextKeyContainer[K, T]])(implicit val typeK: TypeRep[K], val typeT: TypeRep[T]) extends FieldDef[T](self, "current") {
    override def curriedConstructor = (copy[K, T] _)
    override def isPure = true

  }

  // method definitions
  def nextKeyContainerNew[K, T](current: Rep[T], key: Rep[K], next: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[NextKeyContainer[K, T]] = NextKeyContainerNew[K, T](current, key, next)
  def nextKeyContainer_Field_Next_$eq[K, T](self: Rep[NextKeyContainer[K, T]], x$1: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[Unit] = NextKeyContainer_Field_Next_$eq[K, T](self, x$1)
  def nextKeyContainer_Field_Next[K, T](self: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[NextKeyContainer[K, T]] = NextKeyContainer_Field_Next[K, T](self)
  def nextKeyContainer_Field_Key_$eq[K, T](self: Rep[NextKeyContainer[K, T]], x$1: Rep[K])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[Unit] = NextKeyContainer_Field_Key_$eq[K, T](self, x$1)
  def nextKeyContainer_Field_Key[K, T](self: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[K] = NextKeyContainer_Field_Key[K, T](self)
  def nextKeyContainer_Field_Current[K, T](self: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[T] = NextKeyContainer_Field_Current[K, T](self)
  type NextKeyContainer[K, T] = ch.epfl.data.legobase.NextKeyContainer[K, T]
}
trait NextKeyContainerImplicits {
  // Add implicit conversions here!
}
trait NextKeyContainerImplementations {

}
trait NextKeyContainerPartialEvaluation extends NextKeyContainerComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def nextKeyContainer_Field_Current[K, T](self: Rep[NextKeyContainer[K, T]])(implicit typeK: TypeRep[K], typeT: TypeRep[T]): Rep[T] = self match {
    case Def(node: NextKeyContainerNew[_, _]) => node.current
    case _                                    => super.nextKeyContainer_Field_Current[K, T](self)(typeK, typeT)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait NextKeyContainerComponent extends NextKeyContainerOps with NextKeyContainerImplicits {}

trait K2DBScannerOps extends Base with OptimalStringOps {
  // Type representation
  case object K2DBScannerType extends TypeRep[K2DBScanner] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = K2DBScannerType
    val name = "K2DBScanner"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[K2DBScanner]
  }
  implicit val typeK2DBScanner = K2DBScannerType
  implicit class K2DBScannerRep(self: Rep[K2DBScanner]) {
    def next_int(): Rep[Int] = k2DBScannerNext_int(self)
    def next_double(): Rep[Double] = k2DBScannerNext_double(self)
    def next_char(): Rep[Char] = k2DBScannerNext_char(self)
    def next(buf: Rep[Array[Byte]])(implicit overload1: Overloaded1): Rep[Int] = k2DBScannerNext1(self, buf)
    def next(buf: Rep[Array[Byte]], offset: Rep[Int])(implicit overload2: Overloaded2): Rep[Int] = k2DBScannerNext2(self, buf, offset)
    def next_date: Rep[Int] = k2DBScannerNext_date(self)
    def hasNext(): Rep[Boolean] = k2DBScannerHasNext(self)
    def delimiter_=(x$1: Rep[Char]): Rep[Unit] = k2DBScanner_Field_Delimiter_$eq(self, x$1)
    def delimiter: Rep[Char] = k2DBScanner_Field_Delimiter(self)
    def intDigits_=(x$1: Rep[Int]): Rep[Unit] = k2DBScanner_Field_IntDigits_$eq(self, x$1)
    def intDigits: Rep[Int] = k2DBScanner_Field_IntDigits(self)
    def byteRead_=(x$1: Rep[Int]): Rep[Unit] = k2DBScanner_Field_ByteRead_$eq(self, x$1)
    def byteRead: Rep[Int] = k2DBScanner_Field_ByteRead(self)
    def filename: Rep[String] = k2DBScanner_Field_Filename(self)
  }
  object K2DBScanner {

  }
  // constructors
  def __newK2DBScanner(filename: Rep[String]): Rep[K2DBScanner] = k2DBScannerNew(filename)
  // case classes
  case class K2DBScannerNew(filename: Rep[String]) extends ConstructorDef[K2DBScanner](List(), "K2DBScanner", List(List(filename))) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_int(self: Rep[K2DBScanner]) extends FunctionDef[Int](Some(self), "next_int", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_double(self: Rep[K2DBScanner]) extends FunctionDef[Double](Some(self), "next_double", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_char(self: Rep[K2DBScanner]) extends FunctionDef[Char](Some(self), "next_char", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext1(self: Rep[K2DBScanner], buf: Rep[Array[Byte]]) extends FunctionDef[Int](Some(self), "next", List(List(buf))) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScannerNext2(self: Rep[K2DBScanner], buf: Rep[Array[Byte]], offset: Rep[Int]) extends FunctionDef[Int](Some(self), "next", List(List(buf, offset))) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScannerNext_date(self: Rep[K2DBScanner]) extends FunctionDef[Int](Some(self), "next_date", List()) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerHasNext(self: Rep[K2DBScanner]) extends FunctionDef[Boolean](Some(self), "hasNext", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_Delimiter_$eq(self: Rep[K2DBScanner], x$1: Rep[Char]) extends FieldSetter[Char](self, "delimiter", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_Delimiter(self: Rep[K2DBScanner]) extends FieldGetter[Char](self, "delimiter") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_IntDigits_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]) extends FieldSetter[Int](self, "intDigits", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_IntDigits(self: Rep[K2DBScanner]) extends FieldGetter[Int](self, "intDigits") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_ByteRead_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]) extends FieldSetter[Int](self, "byteRead", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_ByteRead(self: Rep[K2DBScanner]) extends FieldGetter[Int](self, "byteRead") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_Filename(self: Rep[K2DBScanner]) extends FieldDef[String](self, "filename") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def k2DBScannerNew(filename: Rep[String]): Rep[K2DBScanner] = K2DBScannerNew(filename)
  def k2DBScannerNext_int(self: Rep[K2DBScanner]): Rep[Int] = K2DBScannerNext_int(self)
  def k2DBScannerNext_double(self: Rep[K2DBScanner]): Rep[Double] = K2DBScannerNext_double(self)
  def k2DBScannerNext_char(self: Rep[K2DBScanner]): Rep[Char] = K2DBScannerNext_char(self)
  def k2DBScannerNext1(self: Rep[K2DBScanner], buf: Rep[Array[Byte]]): Rep[Int] = K2DBScannerNext1(self, buf)
  def k2DBScannerNext2(self: Rep[K2DBScanner], buf: Rep[Array[Byte]], offset: Rep[Int]): Rep[Int] = K2DBScannerNext2(self, buf, offset)
  def k2DBScannerNext_date(self: Rep[K2DBScanner]): Rep[Int] = K2DBScannerNext_date(self)
  def k2DBScannerHasNext(self: Rep[K2DBScanner]): Rep[Boolean] = K2DBScannerHasNext(self)
  def k2DBScanner_Field_Delimiter_$eq(self: Rep[K2DBScanner], x$1: Rep[Char]): Rep[Unit] = K2DBScanner_Field_Delimiter_$eq(self, x$1)
  def k2DBScanner_Field_Delimiter(self: Rep[K2DBScanner]): Rep[Char] = K2DBScanner_Field_Delimiter(self)
  def k2DBScanner_Field_IntDigits_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]): Rep[Unit] = K2DBScanner_Field_IntDigits_$eq(self, x$1)
  def k2DBScanner_Field_IntDigits(self: Rep[K2DBScanner]): Rep[Int] = K2DBScanner_Field_IntDigits(self)
  def k2DBScanner_Field_ByteRead_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]): Rep[Unit] = K2DBScanner_Field_ByteRead_$eq(self, x$1)
  def k2DBScanner_Field_ByteRead(self: Rep[K2DBScanner]): Rep[Int] = K2DBScanner_Field_ByteRead(self)
  def k2DBScanner_Field_Filename(self: Rep[K2DBScanner]): Rep[String] = K2DBScanner_Field_Filename(self)
  type K2DBScanner = ch.epfl.data.legobase.storagemanager.K2DBScanner
}
trait K2DBScannerImplicits {
  // Add implicit conversions here!
}
trait K2DBScannerImplementations {

}
trait K2DBScannerPartialEvaluation extends K2DBScannerComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def k2DBScanner_Field_Filename(self: Rep[K2DBScanner]): Rep[String] = self match {
    case Def(node: K2DBScannerNew) => node.filename
    case _                         => super.k2DBScanner_Field_Filename(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait K2DBScannerComponent extends K2DBScannerOps with K2DBScannerImplicits {}

trait WindowRecordOps extends Base with OptimalStringOps {
  // Type representation
  case class WindowRecordType[B, C](typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[WindowRecord[B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = WindowRecordType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    private implicit val tagB = typeB.typeTag
    private implicit val tagC = typeC.typeTag
    val name = s"WindowRecord[${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeB, typeC)
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[WindowRecord[B, C]]
  }
  implicit def typeWindowRecord[B: TypeRep, C: TypeRep] = WindowRecordType(implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class WindowRecordRep[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = windowRecordGetField[B, C](self, key)(typeB, typeC)
    def wnd: Rep[C] = windowRecord_Field_Wnd[B, C](self)(typeB, typeC)
    def key: Rep[B] = windowRecord_Field_Key[B, C](self)(typeB, typeC)
  }
  object WindowRecord {

  }
  // constructors
  def __newWindowRecord[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = windowRecordNew[B, C](key, wnd)(typeB, typeC)
  // case classes
  case class WindowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[WindowRecord[B, C]](List(typeB, typeC), "WindowRecord", List(List(key, wnd))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[C](self, "wnd") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

  }

  case class WindowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

  }

  // method definitions
  def windowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = WindowRecordNew[B, C](key, wnd)
  def windowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Option[Any]] = WindowRecordGetField[B, C](self, key)
  def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[C] = WindowRecord_Field_Wnd[B, C](self)
  def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = WindowRecord_Field_Key[B, C](self)
  type WindowRecord[B, C] = ch.epfl.data.legobase.queryengine.WindowRecord[B, C]
}
trait WindowRecordImplicits {
  // Add implicit conversions here!
}
trait WindowRecordImplementations {

}
trait WindowRecordPartialEvaluation extends WindowRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[C] = self match {
    case Def(node: WindowRecordNew[_, _]) => node.wnd
    case _                                => super.windowRecord_Field_Wnd[B, C](self)(typeB, typeC)
  }
  override def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = self match {
    case Def(node: WindowRecordNew[_, _]) => node.key
    case _                                => super.windowRecord_Field_Key[B, C](self)(typeB, typeC)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait WindowRecordComponent extends WindowRecordOps with WindowRecordImplicits {}

trait DeepDSL extends push.OperatorsComponent
  with AGGRecordComponent
  with WindowRecordComponent
  with CharComponent
  with DoubleComponent
  with IntComponent
  with LongComponent
  with ArrayComponent
  with GroupByClassComponent
  with Q3GRPRecordComponent
  with Q7GRPRecordComponent
  with Q9GRPRecordComponent
  with Q10GRPRecordComponent
  with Q16GRPRecord1Component
  with Q16GRPRecord2Component
  with Q18GRPRecordComponent
  with Q20GRPRecordComponent
  with GenericEngineComponent
  with LINEITEMRecordComponent
  with SUPPLIERRecordComponent
  with PARTSUPPRecordComponent
  with REGIONRecordComponent
  with NATIONRecordComponent
  with PARTRecordComponent
  with CUSTOMERRecordComponent
  with ORDERSRecordComponent
  with OptimalStringComponent
  with LoaderComponent
  with K2DBScannerComponent
  with IntegerComponent
  with NextContainerComponent
  with NextKeyContainerComponent
  with BooleanComponent
  with HashMapComponent
  with SetComponent
  with TreeSetComponent
  with ArrayBufferComponent
  with ManualLiftedLegoBase
  with QueryComponent

